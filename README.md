# Technical Interview Preparation

This repository has practical content that covers all phases of a technical interview
The information in this repository is condensed. Ultimately, the key to succeeding in technical interviews is consistent practice.

## Who is this for?

Anybody who wants to land a job at a tech company but is new to technical interviews, seasoned engineers who have not been on the other side of the interviewing table in a while and want to get back into the game, or anyone who wants to be better at technical interviewing.

## What will we cover??

![Coding at the whiteboard - from HBO's Silicon Valley](https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png)

# Tech Interview Basics

So, what happens in a technical interview? Every company is different, but let‚Äôs take a look at the average situations you might face.

## Stages of the technical interview

Often, tech interviews will come in three basic stages:

**üìû 1st stage: the technical phone or video screen.** Good news! The company liked your resume and wants to talk to you more. This short social & technical screening stage is designed to see if you are qualified and enthusiastic enough to proceed to the next technical round. This interview stage typically lasts 15-30 minutes.

![phone interview](https://learntocodewith.me/wp-content/uploads/2022/02/Video-interview.jpeg)

**üìù 2nd stage: remote coding interview/assignment.** Some companies will want to test your coding skills with a preliminary test before having you actually come in. It may be conducted over the phone, via Skype or Zoom, or could be a homework-type assignment. If the company is respectful of your time, a remote coding challenge should only take a few hours.

![coding assesment](https://miro.medium.com/v2/resize:fit:4800/0*FNmFBRuYueycjFGP)

**üíª 3rd and final stage: onsite interview/whiteboarding challenge.** This is the stage that most people call the actual ‚Äútechnical interview.‚Äù It involves an in-person interview with coding challenges you have to complete on a whiteboard in front of the interviewer(s). This could also be done remotely over video conference if the company is remote. Whiteboard interviews typically last 1-2 hours, but the whole onsite technical interview can be several hours to a full day.

![onsite interview](https://learntocodewith.me/wp-content/uploads/2022/02/Woman-at-whiteboard-interview.jpeg)

# What to Expect When You‚Äôre Interviewing

Let‚Äôs break down each stage of the typical technical interview process, with quick tech interview tips for how to pass a technical interview and stand out in each part.

## During the phone technical phone interview

Here are a few more tips on how to prepare for a technical phone interview:

- Be excited about the company or project, and that positivity will come across in the interview.

- Know your audience. If you‚Äôre interviewing with a recruiter (with no programming knowledge), play up your soft skills and don‚Äôt get too technical. If you‚Äôre interviewing with a software developer, show off that tech knowledge!
- Be honest: tell the interviewer what most interests you in a job and what kinds of projects you‚Äôd like to work on.
- Answer behavioral questions by showing, not telling. Use specific, memorable details and tell a story.

## What interviewers are looking for in the phone interview

Beyond just pure tech skills, which they‚Äôve already read about on your resume, interviewers in a phone screen want to see:

üë©‚Äçüíª Passion for tech/coding

üòÑ Enthusiasm

üó£Ô∏è Communication skills

ü§ó Culture fit

ü§ù Alignment with company mission/values

## How to stand out over the phone

Even if you‚Äôve applied to hundreds of jobs, tailor your answers to the exact one you‚Äôre interviewing for. ‚ÄúWhen a candidate answers the interview questions in a way that is specific to the company and the position, it shows that they have done their research,‚Äù

Also, look for opportunities to show your value alignment. When you make it clear that you support the big picture and the mission of the organization, it‚Äôs a great sign that you will be a good fit,‚Äù

## Remote Coding Challenge

This technical round has some flexibility in how companies handle it. So first, let‚Äôs go over some of the common types of remote programming interview questions or challenges.

- Some companies will give you a real-time monitored challenge to see how you code. Often this is done via a video interview + a web-based code editor like CoderPad, Collabedit, or even a Google Doc.
- Other companies (usually startups) may simply require you to complete an at-home assignment instead within a set time limit‚Äìusually 48 hours.
- Really small startups may not include a remote coding challenge at all‚Äìinstead bringing you in for an onsite interview immediately after the phone interview‚Äìbut bigger companies often do. (General rule: the bigger the company, the more structured the hiring process is.)

## coding interview preparation tips for the remote coding challenge

During a real-time coding challenge, communicate with your interviewer and think out loud. Make it a collaborative process (use ‚Äúwe‚Äù instead of ‚ÄúI‚Äù), since interviewers want to know that you‚Äôre a team player. And remember to slow down. These real-time challenges are not usually timed, so take your time, think it through, and give the interviewer a chance to give you hints.

During a take-home coding assignment, take time to plan out your code before writing it out. Make sure you fully understand the instructions and requirements. Re-read them several times before starting and once more after you‚Äôre finished with the challenge to make sure you‚Äôve ticked every box.

## What interviewers are looking for in the coding challenge

- Coding skills
- Testing code as you write it
- Problem-solving skills
  -Collaboration skills

## How to stand out in a remote coding challenge

One way to stand out in your remote coding challenge technical round is to go above and beyond. Sometimes remote coding challenges will come with optional ‚Äúbonus‚Äù requirements. Complete those requirements to impress your interviewers.

## Onsite interview and Whiteboard challenge

I must say this is the most intimidating part of the entire tech interview process. But i will share more on how to prepare for your technical interview further down

## What to do during the onsite technical interview

1. Ask clarifying questions before you even start writing code.

   Instead of starting to write out your code immediately, slow down. Even if you think you already know how to solve the problem or answer the question, ask clarifying questions. By doing this, you might get hints from the interviewer, plus you want to make sure you fully understand the challenge/question before diving in.

2. Talk through your code (think out loud) to give the interviewer a window into your thoughts.

   What happens in a technical interview is as much about the journey as the destination. It‚Äôs designed to test a candidate‚Äôs communication and problem-solving skills. More important than the solution is how you work at getting the solution. Can you articulate your thoughts while writing out the code on the whiteboard? Are you putting together a clear response to the question?

3. Speak clearly and precisely.

   Being in a high-pressure situation like a programming interview might have you a little flustered, but work through it. Being as clear and specific as possible can help you keep yourself collected.

4. If you‚Äôre stuck, stay calm, think out loud, and try new ideas

   Not sure of the answer to some coding interview questions? Start with what you do know. Coding interviews are a lot like math exams in high school and university: often, you‚Äôll get ‚Äòpartial credit‚Äô for showing your work and putting in some effort to find a solution. If you can demonstrate your thought process, the interviewer will understand that you‚Äôre doing your best to find a solution.

   How to pass a technical interview isn‚Äôt always about getting everything 100% right, but staying cool and rational under pressure will always help!

5. Check for errors & walk through your solution at the end

   Companies want to hire software engineers who can write bug-free code, or at least know how to check for errors. Towards the end of writing out your solution, begin to check for any errors. This can show interviewers that you‚Äôre not just interested in writing code, but that you want to write good code.

## What interview skills employers look for in onsite technical interview

- Coding skills
- Problem-solving ability
- Ability to think creatively
- Communication skills
- Analytical thinking skills
- Culture fit
- How you handle feedback

# Coding Interview Preparation

## What are Data Structures

The elementary particles of algorithms, data structures are woven into the very fabric of computer science and are essential building blocks of many a solution to coding interview problems.

## Arrays

![arrays](https://cdn-media-1.freecodecamp.org/images/1*plaTqL5DDa2MgqeK-0EClg.png)

Perhaps the most classic and most commonly used of all data structures

Arrays are a linear collection of data values that are accessible at numbered indices,starting at index 0

Arrays take advantage of this ‚Äúgrid‚Äù structure to store lists of related information in adjacent memory locations to guarantee extreme efficiency for finding those values. üî≥üî≥üî≥üî≥

![array sample](https://cdn-media-1.freecodecamp.org/images/HjKZtf6JKxcrH8t51iRrId-4lTqjOlGtICip)

Their elements are next to each other in memory. If you need to access more than one of them, the process is extremely optimized because your computer already knows where the value is located.

The following are an array's standard operations and their corresponding time
complexities:

- Accessing a value at a given index: O(1)
- Updating a value at a given index: O(1)
- Inserting a value at the beginning:O(n)
- Inserting a value in the middle:O(n)
- Inserting a value at the end:
  - amortized O(1) when dealing with a dynamic array
  - O(n) when dealing with static array
- Removing a value at the beginning:O(n)
- Removing a value in the middle: O(n)
- Removing a value at the end: O(1)
- Copying the array:O(n)

A static array is an implementation of an array that allocates a fixed amount of memory to be used for storing the array's values. Appending values to the array therefore involves copying the entire array and allocating new memory for it, accounting for the extra space needed for the newly appended value.
This is a linear-time operation.

A dynamic array is an implementation of an array that preemptively allocates double the amount of memory needed to store the array's values. Appending values to the array is a constant-time operation until the allocated memory is filled up, at which point the array is copied and double the memory is once again allocated for it. This implementation leads to an amortized constant-time insertion-at-end operation.

## Linked Lists

![linked lists](https://cdn-media-2.freecodecamp.org/w1280/5f9c9a86740569d1a4ca2622.jpg)

## What is a linked list

A linked list is a linear data structure similar to an array. However, unlike arrays, elements are not stored in a particular memory location or index. Rather each element is a separate object that contains a pointer or a link to the next object in that list.

Each element (commonly called nodes) contains two items: the data stored and a link to the next node. The data can be any valid data type. You can see this illustrated in the diagram below.

![example linked list](https://res.cloudinary.com/dvj2hbywq/image/upload/v1590572188/Group_14_5_bvpwu0.png)

The entry point to a linked list is called the head. The head is a reference to the first node in the linked list. The last node on the list points to null. If a list is empty, the head is a null reference.

In JavaScript, a linked list looks like this:

```
const list = {
    head: {
        value: 6
        next: {
            value: 10
            next: {
                value: 12
                next: {
                    value: 3
                    next: null
                    }
                }
            }
        }
    }
};

```

## Advantages of Linked lists

Nodes can easily be removed or added from a linked list without reorganizing the entire data structure. This is one advantage it has over arrays.

## Disadvantages of Linked Lists

- Search operations are slow in linked lists. Unlike arrays, random access of data elements is not allowed. Nodes are accessed sequentially starting from the first node.
- It uses more memory than arrays because of the storage of the pointers.

## Types of Linked lists

- **Singly Linked Lists:** Each node contains only one pointer to the next node. This is what we have been talking about so far.

The following are a singly linked list's standard operations and their corresponding time
complexities:

- Accessing the head: O(1)
- Accessing the tail: O(n)
- Accessing a middle node: O(n)
- Inserting/Removing the head: O(1)
- Inserting/Removing the tail: O(n) to access + O(1)
- Inserting/Removing a middle node: O(n) to access + O(1)
- Searching for a value: O(n)

- **Doubly Linked Lists:** Each node contains two pointers, a pointer to the next node and a pointer to the previous node.

The following are a doubly linked list's standard operations and their corresponding time
complexities:

- Accessing the head: O(1)
- Accessing the tail: O(1)
- Accessing a middle node: O(n)
- Inserting/Removing the head: O(1)
- Inserting/Removing the tail: O(1)
- Inserting/Removing a middle node: O(n) to access + O(1)
- Searching for a value: O(n)

- **Circular Linked Lists:** Circular linked lists are a variation of a linked list in which the last node points to the first node or any other node before it, thereby forming a loop.

## Implementing a List Node in JavaScript

As stated earlier, a list node contains two items: the data and the pointer to the next node. We can implement a list node in JavaScript as follows:

```
class ListNode {
    constructor(data) {
        this.data = data
        this.next = null
    }
}
```

## Implementing a Linked List in JavaScript

The code below shows the implementation of a linked list class with a constructor. Notice that if the head node is not passed, the head is initialised to null.

```
class LinkedList {
    constructor(head = null) {
        this.head = head
    }
}
```

## Putting it all together

Let's create a linked list with the class we just created. First, we create two list nodes, node1 and node2 and a pointer from node 1 to node 2.

```
let node1 = new ListNode(2)
let node2 = new ListNode(5)
node1.next = node2
```

Next, we'll create a Linked list with the node1.

```
let list = new LinkedList(node1)
```

Let's try to access the nodes in the list we just created.

```
console.log(list.head.next.data) //returns 5
```

## Some LinkedList methods

Next up, we will implement four helper methods for the linked list. They are:

1. size()
2. clear()
3. getLast()
4. getFirst()

## 1. size()

This method returns the number of nodes present in the linked list.

```
size() {
    let count = 0;
    let node = this.head;
    while (node) {
        count++;
        node = node.next
    }
    return count;
}
```

## 2. clear()

This method empties out the list.

```
clear() {
    this.head = null;
}
```

## 3. getLast()

This method returns the last node of the linked list.

```
getLast() {
    let lastNode = this.head;
    if (lastNode) {
        while (lastNode.next) {
            lastNode = lastNode.next
        }
    }
    return lastNode
}
```

## 4. getFirst()

This method returns the first node of the linked list.

```
getFirst() {
    return this.head;
}
```

## Stacks

![stacks](https://cdn-media-1.freecodecamp.org/images/0*NEPg2w2qm-aTdb1a)

Stacks are an array-like data structure whose elements follow the **LIFO** rule: **L**ast **I**n, **F**irst **O**ut.

A stack is often compared to a stack of books on a table: the last book that's placed on the stack of books is the first one that's taken off the stack

JavaScript is a single threaded language. In the simplest terms, it means it can only do one thing at a time, just like us. So how does our language of choice handle this in an organized way, Stacks?

![stacks example](https://cdn-media-1.freecodecamp.org/images/K4D9kYqy74hwfMaEvoj6TMVAioUxmyUY5vfG)

As you can see, the stack is a clean way of handling tasks, removing them, and eventually getting back to the beginning.

Stacks come with a cost: memory. For every item we place on the stack, we allocate a stack frame to it. Think of an array index. Each index is allocated space to hold something. If we keep adding and adding to a stack, we hold the possibility of running out of space, like a parking lot that is full. When that happens, we have an overflow, hence, the term ‚Äústack overflow‚Äù. This can lead to crashes and stuck processes.

![stack overflow image](https://cdn-media-1.freecodecamp.org/images/2oeYQbArqT5t5TfIjqkI5i86QjaFUynSqyY5)

The following are stacks standard operations and their corresponding time
complexities:

- Pushing an element onto the stack: O(1)
- Popping an element off the stack: O(1)
- Peeking at the element on the top of the stack: O(1)
- Searching for an element in the stack: O(n)

A stack is typically implemented with a **dynamic array** or with a **singly linked list**

## Implementation

First, how do we store the data? What can we use in JavaScript to hold data? We can use native objects like arrays, which we are familiar with and use built-in methods, push and pop. Ok, I guess we‚Äôre done, see you later‚Ä¶

Nah, to understand how a stack works under the hood, we use the base Object form.

We need a constructor to establish the storage mechanism and properties upon its invocation.

```
// Stack class
class Stack {

    // Array is used to implement stack
    constructor()
    {
        this.items = [];
    }

    // Functions to be implemented
    // push(item)
    // pop()
    // peek()
    // isEmpty()
    // printStack()
}
```

As you can see the above definition we have created a skeleton of a stack class which contains a constructor in which we declare an array to implement stack. Hence, with the creation of an object of a stack class this constructor would be called automatically.

- PUSH: Adds an element to the stack and

```
// push function
push(element)
{
    // push element into the items
    this.items.push(element);
}
```

This method adds an element at the top of the stack.

- POP: Removes an element from the stack

```
// pop function
pop()
{
    // return top most element in the stack
    // and removes it from the stack
    // Underflow if stack is empty
    if (this.items.length == 0)
        return "Underflow";
    return this.items.pop();
}
```

This method returns the topmost element of stack and removes it.

- PEEK: returns the top most elements in the stack, but doesn‚Äôt delete it.

```
// peek function
peek()
{
    // return the top most element from the stack
    // but does'nt delete it.
    return this.items[this.items.length - 1];
}
```

## What is Big O

The speed and memory usage of an algorithm aren't necessarily fixed; they might change depending on the input. So how do we express the performance of an algorithm then?

Enter Big O Notation, a powerful tool that allows us to generalize the space-time complexity of an algorithm as a function of its input size.

## Why is Big O important

Understanding the Big O of algorithms will

- get you into the mindset of coding for efficiency. Ex: "I have to change this algorithm because it's O(n!)!"
- help you talk code to other developers. Ex: "Don't worry, I changed up the algorithm so it not O(n^2). It's O(n) now."
- help you for interviews. You will be able to talk about efficiency of algorithms that you whiteboard. Ex: "What I just coded out is O(n^2)."

## Let's dive into 0(1)
