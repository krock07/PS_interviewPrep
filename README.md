# Technical Interview Preparation

This repository has practical content that covers all phases of a technical interview
The information in this repository is condensed. Ultimately, the key to succeeding in technical interviews is consistent practice.

## Who is this for?

Anybody who wants to land a job at a tech company but is new to technical interviews, seasoned engineers who have not been on the other side of the interviewing table in a while and want to get back into the game, or anyone who wants to be better at technical interviewing.

## What will we cover??

![Coding at the whiteboard - from HBO's Silicon Valley](https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png)

- [Tech interview basics](#tech-interview-basics)
- [Data Structures](#what-are-data-structures)
- [Big O notation](#what-is-big-o)
- [Algorithms](#algorithms)
- [Resources](#learning-resources)

[Who am I](https://perscholas.zoom.us/rec/share/2BM-Hx8hUM0hZm8rkZIEx5tcUZoRrWny7aP_QI6PZmorEqU7snOq6X6e9pWaBN4D.VfAVjky_8MqrQJ2w?startTime=1684090562000)

Passcode: TU?4ms@J

[sample mock interview](https://perscholas.zoom.us/rec/share/2BM-Hx8hUM0hZm8rkZIEx5tcUZoRrWny7aP_QI6PZmorEqU7snOq6X6e9pWaBN4D.VfAVjky_8MqrQJ2w?startTime=1684086201000)

Passcode: TU?4ms@J

# Tech Interview Basics

So, what happens in a technical interview? Every company is different, but let‚Äôs take a look at the average situations you might face.

## Stages of the technical interview

Often, tech interviews will come in three basic stages:

**üìû 1st stage: the technical phone or video screen.** Good news! The company liked your resume and wants to talk to you more. This short social & technical screening stage is designed to see if you are qualified and enthusiastic enough to proceed to the next technical round. This interview stage typically lasts 15-30 minutes.

![phone interview](https://learntocodewith.me/wp-content/uploads/2022/02/Video-interview.jpeg)

**üìù 2nd stage: remote coding interview/assignment.** Some companies will want to test your coding skills with a preliminary test before having you actually come in. It may be conducted over the phone, via Skype or Zoom, or could be a homework-type assignment. If the company is respectful of your time, a remote coding challenge should only take a few hours.

![coding assesment](https://miro.medium.com/v2/resize:fit:4800/0*FNmFBRuYueycjFGP)

**üíª 3rd and final stage: onsite interview/whiteboarding challenge.** This is the stage that most people call the actual ‚Äútechnical interview.‚Äù It involves an in-person interview with coding challenges you have to complete on a whiteboard in front of the interviewer(s). This could also be done remotely over video conference if the company is remote. Whiteboard interviews typically last 1-2 hours, but the whole onsite technical interview can be several hours to a full day.

![onsite interview](https://learntocodewith.me/wp-content/uploads/2022/02/Woman-at-whiteboard-interview.jpeg)

# What to Expect When You‚Äôre Interviewing

Let‚Äôs break down each stage of the typical technical interview process, with quick tech interview tips for how to pass a technical interview and stand out in each part.

## During the phone technical phone interview

Here are a few more tips on how to prepare for a technical phone interview:

- Be excited about the company or project, and that positivity will come across in the interview.

- Know your audience. If you‚Äôre interviewing with a recruiter (with no programming knowledge), play up your soft skills and don‚Äôt get too technical. If you‚Äôre interviewing with a software developer, show off that tech knowledge!
- Be honest: tell the interviewer what most interests you in a job and what kinds of projects you‚Äôd like to work on.
- Answer behavioral questions by showing, not telling. Use specific, memorable details and tell a story.

## What interviewers are looking for in the phone interview

Beyond just pure tech skills, which they‚Äôve already read about on your resume, interviewers in a phone screen want to see:

üë©‚Äçüíª Passion for tech/coding

üòÑ Enthusiasm

üó£Ô∏è Communication skills

ü§ó Culture fit

ü§ù Alignment with company mission/values

## How to stand out over the phone

Even if you‚Äôve applied to hundreds of jobs, tailor your answers to the exact one you‚Äôre interviewing for. ‚ÄúWhen a candidate answers the interview questions in a way that is specific to the company and the position, it shows that they have done their research,‚Äù

Also, look for opportunities to show your value alignment. When you make it clear that you support the big picture and the mission of the organization, it‚Äôs a great sign that you will be a good fit,‚Äù

## Remote Coding Challenge

This technical round has some flexibility in how companies handle it. So first, let‚Äôs go over some of the common types of remote programming interview questions or challenges.

- Some companies will give you a real-time monitored challenge to see how you code. Often this is done via a video interview + a web-based code editor like CoderPad, Collabedit, or even a Google Doc.
- Other companies (usually startups) may simply require you to complete an at-home assignment instead within a set time limit‚Äìusually 48 hours.
- Really small startups may not include a remote coding challenge at all‚Äìinstead bringing you in for an onsite interview immediately after the phone interview‚Äìbut bigger companies often do. (General rule: the bigger the company, the more structured the hiring process is.)

## coding interview preparation tips for the remote coding challenge

During a real-time coding challenge, communicate with your interviewer and think out loud. Make it a collaborative process (use ‚Äúwe‚Äù instead of ‚ÄúI‚Äù), since interviewers want to know that you‚Äôre a team player. And remember to slow down. These real-time challenges are not usually timed, so take your time, think it through, and give the interviewer a chance to give you hints.

During a take-home coding assignment, take time to plan out your code before writing it out. Make sure you fully understand the instructions and requirements. Re-read them several times before starting and once more after you‚Äôre finished with the challenge to make sure you‚Äôve ticked every box.

## What interviewers are looking for in the coding challenge

- Coding skills
- Testing code as you write it
- Problem-solving skills
  -Collaboration skills

## How to stand out in a remote coding challenge

One way to stand out in your remote coding challenge technical round is to go above and beyond. Sometimes remote coding challenges will come with optional ‚Äúbonus‚Äù requirements. Complete those requirements to impress your interviewers.

## Onsite interview and Whiteboard challenge

I must say this is the most intimidating part of the entire tech interview process. But i will share more on how to prepare for your technical interview further down

## What to do during the onsite technical interview

1. Ask clarifying questions before you even start writing code.

   Instead of starting to write out your code immediately, slow down. Even if you think you already know how to solve the problem or answer the question, ask clarifying questions. By doing this, you might get hints from the interviewer, plus you want to make sure you fully understand the challenge/question before diving in.

2. Talk through your code (think out loud) to give the interviewer a window into your thoughts.

   What happens in a technical interview is as much about the journey as the destination. It‚Äôs designed to test a candidate‚Äôs communication and problem-solving skills. More important than the solution is how you work at getting the solution. Can you articulate your thoughts while writing out the code on the whiteboard? Are you putting together a clear response to the question?

3. Speak clearly and precisely.

   Being in a high-pressure situation like a programming interview might have you a little flustered, but work through it. Being as clear and specific as possible can help you keep yourself collected.

4. If you‚Äôre stuck, stay calm, think out loud, and try new ideas

   Not sure of the answer to some coding interview questions? Start with what you do know. Coding interviews are a lot like math exams in high school and university: often, you‚Äôll get ‚Äòpartial credit‚Äô for showing your work and putting in some effort to find a solution. If you can demonstrate your thought process, the interviewer will understand that you‚Äôre doing your best to find a solution.

   How to pass a technical interview isn‚Äôt always about getting everything 100% right, but staying cool and rational under pressure will always help!

5. Check for errors & walk through your solution at the end

   Companies want to hire software engineers who can write bug-free code, or at least know how to check for errors. Towards the end of writing out your solution, begin to check for any errors. This can show interviewers that you‚Äôre not just interested in writing code, but that you want to write good code.

## What interview skills employers look for in onsite technical interview

- Coding skills
- Problem-solving ability
- Ability to think creatively
- Communication skills
- Analytical thinking skills
- Culture fit
- How you handle feedback

# Coding Interview Preparation

## What are Data Structures

The elementary particles of algorithms, data structures are woven into the very fabric of computer science and are essential building blocks of many a solution to coding interview problems.

## Arrays

![arrays](https://cdn-media-1.freecodecamp.org/images/1*plaTqL5DDa2MgqeK-0EClg.png)

Perhaps the most classic and most commonly used of all data structures

Arrays are a linear collection of data values that are accessible at numbered indices,starting at index 0

Arrays take advantage of this ‚Äúgrid‚Äù structure to store lists of related information in adjacent memory locations to guarantee extreme efficiency for finding those values. üî≥üî≥üî≥üî≥

![array sample](https://cdn-media-1.freecodecamp.org/images/HjKZtf6JKxcrH8t51iRrId-4lTqjOlGtICip)

Their elements are next to each other in memory. If you need to access more than one of them, the process is extremely optimized because your computer already knows where the value is located.

The following are an array's standard operations and their corresponding time
complexities:

- Accessing a value at a given index: O(1)
- Updating a value at a given index: O(1)
- Inserting a value at the beginning:O(n)
- Inserting a value in the middle:O(n)
- Inserting a value at the end:
  - amortized O(1) when dealing with a dynamic array
  - O(n) when dealing with static array
- Removing a value at the beginning:O(n)
- Removing a value in the middle: O(n)
- Removing a value at the end: O(1)
- Copying the array:O(n)

A static array is an implementation of an array that allocates a fixed amount of memory to be used for storing the array's values. Appending values to the array therefore involves copying the entire array and allocating new memory for it, accounting for the extra space needed for the newly appended value.
This is a linear-time operation.

A dynamic array is an implementation of an array that preemptively allocates double the amount of memory needed to store the array's values. Appending values to the array is a constant-time operation until the allocated memory is filled up, at which point the array is copied and double the memory is once again allocated for it. This implementation leads to an amortized constant-time insertion-at-end operation.

## Linked Lists

![linked lists](https://cdn-media-2.freecodecamp.org/w1280/5f9c9a86740569d1a4ca2622.jpg)

## What is a linked list

A linked list is a linear data structure similar to an array. However, unlike arrays, elements are not stored in a particular memory location or index. Rather each element is a separate object that contains a pointer or a link to the next object in that list.

Each element (commonly called nodes) contains two items: the data stored and a link to the next node. The data can be any valid data type. You can see this illustrated in the diagram below.

![example linked list](https://res.cloudinary.com/dvj2hbywq/image/upload/v1590572188/Group_14_5_bvpwu0.png)

The entry point to a linked list is called the head. The head is a reference to the first node in the linked list. The last node on the list points to null. If a list is empty, the head is a null reference.

In JavaScript, a linked list looks like this:

```js
const list = {
    head: {
        value: 6
        next: {
            value: 10
            next: {
                value: 12
                next: {
                    value: 3
                    next: null
                    }
                }
            }
        }
    }
};

```

## Advantages of Linked lists

Nodes can easily be removed or added from a linked list without reorganizing the entire data structure. This is one advantage it has over arrays.

## Disadvantages of Linked Lists

- Search operations are slow in linked lists. Unlike arrays, random access of data elements is not allowed. Nodes are accessed sequentially starting from the first node.
- It uses more memory than arrays because of the storage of the pointers.

## Types of Linked lists

- **Singly Linked Lists:** Each node contains only one pointer to the next node. This is what we have been talking about so far.

The following are a singly linked list's standard operations and their corresponding time
complexities:

- Accessing the head: O(1)
- Accessing the tail: O(n)
- Accessing a middle node: O(n)
- Inserting/Removing the head: O(1)
- Inserting/Removing the tail: O(n) to access + O(1)
- Inserting/Removing a middle node: O(n) to access + O(1)
- Searching for a value: O(n)

- **Doubly Linked Lists:** Each node contains two pointers, a pointer to the next node and a pointer to the previous node.

The following are a doubly linked list's standard operations and their corresponding time
complexities:

- Accessing the head: O(1)
- Accessing the tail: O(1)
- Accessing a middle node: O(n)
- Inserting/Removing the head: O(1)
- Inserting/Removing the tail: O(1)
- Inserting/Removing a middle node: O(n) to access + O(1)
- Searching for a value: O(n)

- **Circular Linked Lists:** Circular linked lists are a variation of a linked list in which the last node points to the first node or any other node before it, thereby forming a loop.

- Visualize building a [linked list](https://visualgo.net/bn/list).

## Stacks

![stacks](https://cdn-media-1.freecodecamp.org/images/0*NEPg2w2qm-aTdb1a)

Stacks are an array-like data structure whose elements follow the **LIFO** rule: **L**ast **I**n, **F**irst **O**ut.

A stack is often compared to a stack of books on a table: the last book that's placed on the stack of books is the first one that's taken off the stack

JavaScript is a single threaded language. In the simplest terms, it means it can only do one thing at a time, just like us. So how does our language of choice handle this in an organized way, Stacks?

![stacks example](https://cdn-media-1.freecodecamp.org/images/K4D9kYqy74hwfMaEvoj6TMVAioUxmyUY5vfG)

As you can see, the stack is a clean way of handling tasks, removing them, and eventually getting back to the beginning.

Stacks come with a cost: memory. For every item we place on the stack, we allocate a stack frame to it. Think of an array index. Each index is allocated space to hold something. If we keep adding and adding to a stack, we hold the possibility of running out of space, like a parking lot that is full. When that happens, we have an overflow, hence, the term ‚Äústack overflow‚Äù. This can lead to crashes and stuck processes.

![stack overflow image](https://cdn-media-1.freecodecamp.org/images/2oeYQbArqT5t5TfIjqkI5i86QjaFUynSqyY5)

The following are stacks standard operations and their corresponding time
complexities:

- Pushing an element onto the stack: O(1)
- Popping an element off the stack: O(1)
- Peeking at the element on the top of the stack: O(1)
- Searching for an element in the stack: O(n)

A stack is typically implemented with a **dynamic array** or with a **singly linked list**

## Applications for a stack data structure

- Using the back and forward buttons in your browser
- Undo/redo
- Call stack
- Expression evaluation
- Backtracking (game playing, finding paths, exhaustive searching)
- Memory management, run-time environment for nested language features.

## Queue

![the queue](https://www.javascripttutorial.net/wp-content/uploads/2019/12/queue-at-a-bank.png)

Queues are an array-like data structure whose elements follow the **FIFO** rule: **F**irst **I**n, **F**irst **O**ut.

A queue is often compared to a group of people standing in line to purchase items at a store: the first person to get in line is the first one to purchase items and get out of the queue

The main reason is queues process data fairly and preserve the order of the collection. This also happens when we iterate over items with a for or while loop, forEach(), or map() method. Each item in the array gets processed in the order it was inserted, from index 0 to index.length ‚Äî 1.

**In Queues, items are processed in the order they are inserted.**

When an item is inserted into a queue, it‚Äôs called **enqueued**. When an item is removed, it is **dequeued**. Other methods include peek, contains, until, and count.

The following are queue's standard operations and their corresponding time
complexities:

- Enqueuing an element into he queue: O(1)
- Dequeuing an element out of the queue: O(1)
- Peeking at the element at the front of the queue: O(1)
- Searching for an element in the queue: O(n)

A queue is typically implemented with a **doubly linked list**

The following picture illustrates a queue

![queue picture](https://www.javascripttutorial.net/wp-content/uploads/2016/08/JavaScript-Queue-Illustration.png)

## Graphs

![graphs](https://cdn-media-1.freecodecamp.org/images/1*EBtSVCSmRvw40Bmu9vP69A.png)

Graphs are used in diverse industries and fields:

- **GPS systems** and Google Maps use graphs to find the shortest path from one destination to another.
- **Social Networks** use graphs to represent connections between users.
- **The Google Search** algorithm uses graphs to determine the relevance of search results.
- **Operations Research** is a field that uses graphs to find the optimal path to reduce the cost of transportation and delivery of goods and services.
- **Even Chemistry** uses graphs to represent molecules!!! ‚ù§Ô∏è

Graphs are used to represent, find, analyze, and optimize connections between elements (houses, airports, locations, users, articles, etc.).

Here is what a graph looks like

![graph image](https://cdn-media-1.freecodecamp.org/images/vQ77VuGVlTR95GgMxzyKqydIqoRJcPcWrigy)

Circles represent Nodes and the lines represent Edges

![detailed graph](https://cdn-media-1.freecodecamp.org/images/9KFiyFYi9bMktsJkMKLKaeJl31heUN9A-xrr)

- **Nodes** they are the elements that create the network. They could represent houses, locations, airports, ports, bus stops, buildings, users, basically anything that you could represent as being connected to other similar elements in a network.
- **Edges** are connections between the nodes. They could represent streets, flights, bus routes, a connection between two users in a social network, or anything that could possibly represent a connection between the nodes in the context that you are working with.
- **Graph Cycle** a cycle occurs in a graph when three or more vertices in the graph are connected so as form a closed loop
- **Acyclic Graph** A graph that has no cycles
- **Directed graph** A graph whose edges are directed, meaning that they can only be traversed in one direction, which is specified

**_Example_**

if we create a graph for a pizza delivery service, representing a city, two houses (nodes) may be connected by a one-way street (edge). You could get from house A to house B through this street, but you couldn‚Äôt go back, so you would have to take an alternative path.

![directed graph example](https://cdn-media-1.freecodecamp.org/images/U7ZcYL5X54m06sKCuQ3wv8K2-Ka7ixE67nxg)

- **Undirected Graph** A graph whose edges undirected, meaning they can be traversed in both directions

**_Example_**

For our pizza delivery service, this would mean that the delivery motorcycle can go from the source to the destination through the same street or path (To their relief! üòá).

![Undirected graph example](https://cdn-media-1.freecodecamp.org/images/ijCoLsVRLPWxVTmUI13tnv-aTOtyiHHonk11)

- **Connected graph** A graph is connected if for every pair of vertices iin the graph there's a path of one or more edges connecting the given vertices

## Hash tables

![hash tables](https://www.freecodecamp.org/news/content/images/size/w2000/2021/05/JavaScript-Hash-Table.png)

Fun. Fast. Flexible. This beloved data structure is a fan favorite among interviewers and interviewees alike, and for good reason: it lends itself extremely well to any problem requiring some sort of lookup operation, of which (spoiler alert) there are many.

A hash table, also known as a hash map, is a data structure that maps keys to values. It is one part of a technique called hashing, the other of which is a hash function. A hash function is an algorithm that produces an index of where a value can be found or stored in the hash table.

Some important notes about hash tables:

1. Values are not stored in a sorted order.

2. You must account for potential collisions. This is usually done with a technique called chaining. Chaining means to create a linked list of values, the keys of which map to a certain index.

You'll commonly use a Hash Table because of its fast search, insertion, and delete operations:

**HASH TABLE TIME COMPLEXITY IN BIG O NOTATION**

| Algorithm | Average | Worst case |
| :-------- | :-----: | ---------: |
| Space     |  O(n)   |       O(n) |
| Search    |  O(1)   |       O(n) |
| Insert    |  O(1)   |       O(n) |
| Delete    |  O(1)   |       O(n) |

# Trees

![Binary](https://cdn-media-1.freecodecamp.org/images/2rTqYlcrnWtICedt131tDft0CmkzZaViExJX)

A BST is considered a data structure made up of nodes, like Linked Lists. These nodes are either null or have references (links) to other nodes. These ‚Äòother‚Äô nodes are child nodes, called a left node and right node. Nodes have values. These values determine where they are placed within the BST.

Similarly to a linked list, each node is referenced by only one other node, its parent (except for the root node). So we can say that each node in a BST is in itself a BST. Because further down the tree, we reach another node and that node has a left and a right. Then depending on which way we go, that node has a left and a right and so on.

1. The left node is always smaller than its parent.

2. The right node is always greater than its parent.

3. A BST is considered balanced if every level of the tree is fully filled with the exception of the last level. On the last level, the tree is filled left to right.

4. A Perfect BST is one in which it is both full and complete (all child nodes are on the same level and each node has a left and a right child node).

## Why use BST

What are some real-world examples of BST‚Äôs? Trees are often used in search, game logic, autocomplete tasks, and graphics.

Speed. As mentioned earlier, the BST is an ordered data structure. Upon insertion, the nodes are placed in an orderly fashion. This inherent order makes searching fast. Similar to binary search (with an array that is sorted), we cut the amount of data to sort through by half on each pass. For example, suppose we are looking for a small node value. On each pass, we keep moving along the leftmost node. This eliminates half the greater values automatically!

Also, unlike an array, the data is stored by reference. As we add to the data structure, we create a new chunk in memory and link to it. This is faster than creating a new array with more space and then inserting the data from the smaller array to the new, larger one.

In short, inserting, deleting and searching are the all-stars for a BST

Now that we understand the principles, the benefits, and the basic components of a BST, let‚Äôs implement one in javascript.

There are many types of trees and tree-like structures, including binary trees, heaps, and tries

**_Binary Tree_**
A tree whose nodes have up to two child nodes

The structure of a binary tree is such that many of its operations have a logarithmic time complexity, making the binary tree an incredibly attractive and commonly used data structure.

**_K-ary Tree_**

A tree whose nodes have up to K child-nodes. A binary tree is a k-ary tree where k === 2

**_Perfect Binary tree_**

A Binary tree whose interior nodes all have two child-nodes and whose leaf nodes all have the same depth

```
          1
      /         \
     2           3
   /   \       /   \
  4     5     6     7
 / \   / \   / \   / \
8   9 10 11 12 13 14 15
```

## What is Big O

The speed and memory usage of an algorithm aren't necessarily fixed; they might change depending on the input. So how do we express the performance of an algorithm then?

Enter Big O Notation, a powerful tool that allows us to generalize the space-time complexity of an algorithm as a function of its input size.

## Why is Big O important

Understanding the Big O of algorithms will

- get you into the mindset of coding for efficiency. Ex: "I have to change this algorithm because it's O(n!)!"
- help you talk code to other developers. Ex: "Don't worry, I changed up the algorithm so it not O(n^2). It's O(n) now."
- help you for interviews. You will be able to talk about efficiency of algorithms that you whiteboard. Ex: "What I just coded out is O(n^2)."

## Let's dive into 0(1)

To say an algorithm takes constant (or O(1)) time means: no matter how big the input(s) are, the computer will do basically same amount of work to perform the algorithm on them.

```js
function getMiddleOfArray(array) {
  return array[Math.floor(array.length / 2)];
}
```

## Let's dive into 0(n)

To say an algorithm is linear or O(n) means the resources required grow proportionally to the size of the input.

Algorithms that process each input at least once will take at least O(n) time. Loops are a common example.

```js
function find(needle, haystack) {
  for (var i = 0; i < haystack.length; i++) {
    if (haystack[i] === needle) return true;
  }
}

function crossAdd(input) {
  var answer = [];
  for (var i = 0; i < input.length; i++) {
    var goingUp = input[i];
    var goingDown = input[input.length - 1 - i];
    answer.push(goingUp + goingDown);
  }
  return answer;
}
```

## Lets Dive into O(n¬≤)

```js
function allCombos(list) {
  var results = [];
  for (var i = 0; i < results.length; i++) {
    for (var j = 0; j < results.length; j++) {
      results.push([i, j]);
    }
  }
}
```

This would be O(n¬≤). For every input, we have to go through a full loop inside of another full loop, meaning we're doing a lot of work! This is the trick: look for loops. A loop inside of a loop inside of a loop would likewise be O(n¬≥).

For some people, it's helpful to use a graph to visualize what we're talking about here

![visual representation](https://btholt.github.io/complete-intro-to-computer-science/static/e331672c4244a2ae881a5123175c2c59/5a190/graph.png)

Here we see a graph that represents the more items we put in a array, how long does it take for the function to complete. The red graph represents O(1) like our getMiddleOfArary function. You can throw an array of 1,000,000 at it and it still takes the same amount of time as if the array was 10 big.

The blue line represents a function that takes longer based on how many items are in the array similar to crossAdd or find and it grows a steady rate. If it takes 10ms to run a function with a 100 items in it, we could reasonably expect it would take 10 times longer-ish (remember, these are broad strokes, not precise figures) if we had 10 times the amount of things in the array.

The green line is where we get start getting scary. For every item we add to the array, it takes exponentially more time to complete the operation. Adding 10x the items could cause a function to takes 100x longer since it's O(n¬≤). It gets even scarier at O(n¬≥) as it would take 1000x longer.

## Spatial Complexity

Let's talk about spatial complexity or how much space (e.g. how much RAM or disk space) an algorithm needs to complete.

**_Linear_**

Let's say we have an algorithm that for every item in the array, it needs to create another array in the process of sorting it. So for an array of length 10, our algorithm will create 10 arrays. For an array of 100, it'd create 100 extra arrays (or something close, remember these are broad strokes, not exact.) This would be O(n) in terms of its spatial complexity.

**_Logrithmic_**

What about another for every item in the array, it needed to create a diminishing amount of extra arrays. For example: for an array of length 10, it'd create 7 arrays. For an array of 100, it'd create 12 arrays. For an array of 1000, it'd created 20 arrays. This would be O(log n).

**_Constant_**

What if we didn't create any extra arrays when we did our algorithm? We just used the same space we were given when we first started. Or if we created just 10 arrays, no matter how long the array is? This would be O(1) since it's constant no matter what. Its spatial need don't increase with longer arrays.

**_Quadratic_**

Lastly, what if we had an app that calculates the distances between zip / postal codes?

A zip code in the United States is a five digit number that represents a fairly small area of land. 98109 is in the middle of Seattle, Washington while 10001 is in the middle of New York City, NY.

If a user asks what's the distance between 98109 and 10001, we'd spit out something like 2,800 miles or 4,500 km. Now, let's say for every zip code we add to our system, we calculate the distance between every other zip code in our system and store it. If there were only 10 zip codes, sure, that'd be easy, but there are nearly 42,000 zip codes in the United States with more being added. The spatial complexity on this would be O(n¬≤) because for every new zip code we add, we'd have to add 42,000 new items as well.

# Algorithms

Here is the list of data structures and algorithms you should prepare for coding interviews and their corresponding study guides:

| Topic                 | Priority |
| :-------------------- | :------: |
| Array                 |   High   |
| String                |   High   |
| Hash Table            |   Mid    |
| Recursion             |   Mid    |
| Sorting and searching |   High   |
| Matrix                |   High   |
| Tree                  |   High   |
| Queue                 |   Mid    |
| stack                 |   Mid    |
| graph                 |   high   |
| Recursion             |   Mid    |

## Arrays

**_Common terms_**

Common terms you see when doing problems involving arrays:

- Subarray - A range of contiguous values within an array.
  - Example: given an array [2, 3, 6, 1, 5, 4], [3, 6, 1] is a subarray while [3, 1, 5] is not a subarray.
- Subsequence - A sequence that can be derived from the given sequence by deleting some or no elements without changing the order of the remaining elements.

  - Example: given an array [2, 3, 6, 1, 5, 4], [3, 1, 5] is a subsequence but [3, 5, 1] is not a subsequence.

  **_Time Complexity_**

  | Operation             |   Big-O   |                                                                                                 Note |
  | :-------------------- | :-------: | ---------------------------------------------------------------------------------------------------: |
  | Access                |   O(1)    |                                                                                                      |
  | Search                |   O(n)    |                                                                                                      |
  | Search (sorted array) | O(log(n)) |                                                                                                      |
  | Insert                |   O(n)    | Insertion would require shifting all the subsequent elements to the right by one and that takes O(n) |
  | Insert (at the end)   |   O(1)    |                                 Special case of insertion where no other element needs to be shifted |
  | Delete                |   O(n)    |    Removal would require shifting all the subsequent elements to the left by one and that takes O(n) |
  | Remove (at the end)   |   O(1)    |                                   Special case of removal where no other element needs to be shifted |

## Things to look out for during interviews

- Clarify if there are duplicate values in the array. Would the presence of duplicate values affect the answer? Does it make the question simpler or harder?
- When using an index to iterate through array elements, be careful not to go out of bounds.
- Be mindful about slicing or concatenating arrays in your code. Typically, slicing and concatenating arrays would take O(n) time. Use start and end indices to demarcate a subarray/range where possible.

## Techniques

Note that because both arrays and strings are sequences (a string is an array of characters), most of the techniques here will apply to string problems.

**_Sliding window_**

Master the sliding window technique that applies to many subarray/substring problems. In a sliding window, the two pointers usually move in the same direction will never overtake each other. This ensures that each value is only visited at most twice and the time complexity is still O(n). Examples: Longest Substring Without Repeating Characters, Minimum Size Subarray Sum, Minimum Window Substring

**_Two pointers_**

Two pointers is a more general version of sliding window where the pointers can cross each other and can be on different arrays. Examples: Sort Colors, Palindromic Substrings

When you are given two arrays to process, it is common to have one index per array (pointer) to traverse/compare the both of them, incrementing one of the pointers when relevant. For example, we use this approach to merge two sorted arrays. Examples: Merge Sorted Array

**_Sorting the array_**

Is the array sorted or partially sorted? If it is, some form of binary search should be possible. This also usually means that the interviewer is looking for a solution that is faster than O(n).

Can you sort the array? Sometimes sorting the array first may significantly simplify the problem. Obviously this would not work if the order of array elements need to be preserved. Examples: Merge Intervals, Non-overlapping Intervals

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Two Sum](https://leetcode.com/problems/contains-duplicate/)
- [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)
- [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

## Strings

A string is a sequence of characters

**_Time Complexity_**

A strings is an array of characters, so the time complexities of basic string operations will closely resemble that of array operations.

| Operation | Big-O |
| :-------- | :---: |
| Access    | O(1)  |
| Search    | O(n)  |
| Insert    | O(n)  |
| Remove    | O(n)  |

## Things to look out for during interviews

Ask about input character set and case sensitivity. Usually the characters are limited to lowercase Latin characters, for example a to z.

## Techniques

**_Anagram_**

An anagram is word switch or word play. It is the result of rearranging the letters of a word or phrase to produce a new word or phrase, while using all the original letters only once. In interviews, usually we are only bothered with words without spaces in them.

To determine if two strings are anagrams, there are a few approaches:

Sorting both strings should produce the same resulting string. This takes O(n.log(n)) time and O(log(n)) space.
If we map each character to a prime number and we multiply each mapped number together, anagrams should have the same multiple (prime factor decomposition). This takes O(n) time and O(1) space. Examples: Group Anagram
Frequency counting of characters will help to determine if two strings are anagrams. This also takes O(n) time and O(1) space.
Palindrome
A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward, such as madam or racecar.

Here are ways to determine if a string is a palindrome:

Reverse the string and it should be equal to itself.
Have two pointers at the start and end of the string. Move the pointers inward till they meet. At every point in time, the characters at both pointers should match.
The order of characters within the string matters, so hash tables are usually not helpful.

When a question is about counting the number of palindromes, a common trick is to have two pointers that move outward, away from the middle. Note that palindromes can be even or odd length. For each middle pivot position, you need to check it twice - once that includes the character and once without the character. This technique is used in **_Longest Palindromic Substring_**.

- For substrings, you can terminate early once there is no match

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Valid Anagram](https://leetcode.com/problems/valid-anagram)
- [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
- [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

## Hash Tables

Hashing is the most common example of a space-time tradeoff. Instead of linearly searching an array every time to determine if an element is present, which takes O(n) time, we can traverse the array once and hash all the elements into a hash table. Determining if the element is present is a simple matter of hashing the element and seeing if it exists in the hash table, which is O(1) on average.

In the case of hash collisions, there are a number of collision resolution techniques that can be used. You will unlikely be asked about details of collision resolution techniques in interviews:

- **_Separate chaining_** - A linked list is used for each value, so that it stores all the collided items.
- **_Open addressing_** - All entry records are stored in the bucket array itself. When a new entry has to be inserted, the buckets are examined, starting with the hashed-to slot and proceeding in some probe sequence, until an unoccupied slot is found.

  **_Time Complexity_**

  | Operation | Big-O  |                                                 Note |
  | :-------- | :----: | ---------------------------------------------------: |
  | Access    |  N/A   | Accessing not possible as the hash code is not known |
  | Search    | O(1)\* |                                                      |
  | Insert    | O(1)\* |                                                      |
  | Remove    | O(1)\* |                                                      |

  - This is the average case, but in interviews we only care about the average case for hash tables.

## Sample Questions

- Describe an implementation of a least-used cache, and big-O notation of it.
- A question involving an API's integration with hash map where the buckets of hash map are made up of linked lists.

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Two Sum](https://leetcode.com/problems/two-sum)
- [Ransom Note](https://leetcode.com/problems/ransom-note)

## Sorting and searching cheatsheet

### Introduction

Sorting is the act of rearranging elements in a sequence in order, either in numerical or lexicographical order, and either ascending or descending.

A number of basic algorithms run in O(n2) and should not be used in interviews. In algorithm interviews, you're unlikely to need to implement any of the sorting algorithms from scratch. Instead you would need to sort the input using your language's default sorting function so that you can use binary searches on them.

On a sorted array of elements, by leveraging on its sorted property, searching can be done on them in faster than O(n) time by using a binary search. Binary search compares the target value with the middle element of the array, which informs the algorithm whether the target value lies in the left half or the right half, and this comparison proceeds on the remaining half until the target is found or the remaining half is empty.

## Things to look out for during interviews

Make sure you know the time and space complexity of the language's default sorting algorithm! The time complexity is almost definitely O(nlog(n))). Bonus points if you can name the sort. In Python, it's Timesort. In Java, an implementation of Timesort is used for sorting objects, and Dual-Pivot Quicksort is used for sorting primitives.
b

## Techniques

**_Sorted inputs_**

When a given sequence is in a sorted order (be it ascending or descending), using binary search should be one of the first things that come to your mind.

**_Sorting an input that has limited range_**

Counting sort is a non-comparison-based sort you can use on numbers where you know the range of values beforehand. Examples: [H-Index](https://leetcode.com/problems/h-index/)

## BST Implementation

Binary Search tree is a binary tree in which nodes that have lesser value are stored on the left while the nodes with a higher value are stored at the right.

1. The Node Class
   This class will represent a single node present at various points in the BST. A BST is nothing but a collection of nodes storing data and child references placed according to the rules described above.

```js
class Node {
  constructor(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}
```

To create a new Node instance, we can call this class like this with some data ‚àí

```js
const newNode = new Node(23);
```

2. The Binary Search Tree Class

```js
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
}
```

This will create the Binary Search Tree class which we can call with the new keyword to make a tree instance.

Now as we are done with the basic stuff let‚Äôs move on to inserting a new node at the right place (according to the rules of BST described in definition).

3. Inserting a Node in BST

```js
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
  insert(data) {
    var newNode = new Node(data);
    if (this.root === null) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }
  insertNode(node, newNode) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }
}
```

**_Final code_**

```js
class Node {
  constructor(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
  insert(data) {
    const newNode = new Node(data);
    if (this.root === null) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }
  insertNode(node, newNode) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }
}
const BST = new BinarySearchTree();
BST.insert(1);
BST.insert(3);
BST.insert(2);
```

Now, lets break down each part of this class in more detail

**_The constructor_**

The BinarySearchTree class itself mostly just acts as a housing for the head node. We need to keep a reference to our head because every other node in our tree originates from that node. So if we want to insert a new node into the tree, we have to start from the head because it dictates where all other nodes are placed. I‚Äôve also opted to provide this value with a default assignment of an empty Node instance. That way I can rely on there being a head node present and not have to code defensively around that.

**_The insert() method_**

The insert method is a critical method for any binary search tree because of the strict ordering each node has to adhere to. Remember, the left node must have a value less than its parent, and the right node‚Äôs value must be greater than that of its parent.

As for the algorithm, it‚Äôs quite simple. We traverse through the tree using a while loop that runs until we are out of nodes to check. On each iteration, we compare the value to be inserted to the value of the current node we‚Äôre on. That tells us which side to continue traversing, the left or the right. Then, if there‚Äôs no child node on that side (i.e. left or right are null), we‚Äôll insert a new node with our new value.

Otherwise, if there is a child node there, we‚Äôll set that to be our new current node and the loop continues.

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Binary Search](https://leetcode.com/problems/binary-search/)
- [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- [Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)
- [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)
- [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)
- [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

# Matrix cheatsheet

### Introduction

A matrix is a 2-dimensional array. Questions involving matrices are usually related to dynamic programming or graph traversal.

Matrices can be used to represent graphs where each node is a cell on the matrix which has 4 neighbors (except those cells on the edge and corners). This page will focus on questions which don't use matrix as graphs. Questions which are meant to use the matrix as a graph can be found on the graph section.

## Techniques

### Creating an empty N x M matrix

For questions involving traversal or dynamic programming, you almost always want to make a copy of the matrix with the same size/dimensions that is initialized to empty values to store the visited state or dynamic programming table. Be familiar with such a routine in your language of choice:

### Transposing a matrix

The transpose of a matrix is found by interchanging its rows into columns or columns into rows.

Many grid-based games can be modeled as a matrix, such as Tic-Tac-Toe, Sudoku, Crossword, Connect 4, Battleship, etc. It is not uncommon to be asked to verify the winning condition of the game. For games like Tic-Tac-Toe, Connect 4 and Crosswords, where verification has to be done vertically and horizontally, one trick is to write code to verify the matrix for the horizontal cells, transpose the matrix, and reuse the logic for horizontal verification to verify originally vertical cells (which are now horizontal).

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)
- [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- [Rotate Image](https://leetcode.com/problems/rotate-image/)
- [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

# Linked list cheatsheet

### Introduction

Like arrays, a linked list is used to represent sequential data. It is a linear collection of data elements whose order is not given by their physical placement in memory, as opposed to arrays, where data is stored in sequential blocks of memory. Instead, each element contains an address of the next element. It is a data structure consisting of a collection of nodes which together represent a sequence.

In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence.

### Advantages

Insertion and deletion of a node in the list (given its location) is O(1) whereas in arrays the following elements will have to be shifted.

### Disadvantages

Access time is linear because directly accessing elements by its position in the list is not possible (in arrays you can do arr[4] for example). You have to traverse from the start.

### Types of linked lists

**_Singly linked list_**

A linked list where each node points to the next node and the last node points to null.

**_Doubly linked list_**

A linked list where each node has two pointers, next which points to the next node and prev which points to the previous node. The prev pointer of the first node and the next pointer of the last node point to null.

**_Circular linked list_**

A singly linked list where the last node points back to the first node. There is a circular doubly linked list variant where the prev pointer of the first node points to the last node and the next pointer of the last node points to the first node.

## Time Complexity

| Operation | Big-O |                                                 Note |
| :-------- | :---: | ---------------------------------------------------: |
| Access    | O(n)  |                                                      |
| Search    | O(n)  |                                                      |
| Insert    | O(1)  | Assumes you have traversed to the insertion position |
| Remove    | O(1)  | Assumes you have traversed to the node to be removed |

## Common routines

Be familiar with the following routines because many linked list questions make use of one or more of these routines in the solution:

- Counting the number of nodes in the linked list
- Reversing a linked list in-place
- Finding the middle node of the linked list using two pointers (fast/slow)
- Merging two linked lists together

## Techniques

**_Sentinel/dummy nodes_**

Adding a sentinel/dummy node at the head and/or tail might help to handle many edge cases where operations have to be performed at the head or the tail. The presence of dummy nodes essentially ensures that operations will never have be done on the head or the tail, thereby removing a lot of headache in writing conditional checks to dealing with null pointers. Be sure to remember to remove them at the end of the operation.

**_Two pointers_**

Two pointer approaches are also common for linked lists. This approach is used for many classic linked list problems.

- Getting the kth from last node - Have two pointers, where one is k nodes ahead of the other. When the node ahead reaches the end, the other node is k nodes behind
- Detecting cycles - Have two pointers, where one pointer increments twice as much as the other, if the two pointers meet, means that there is a cycle
- Getting the middle node - Have two pointers, where one pointer increments twice as much as the other. When the faster node reaches the end of the list, the slower node will be at the middle

**_Using space_**

Many linked list problems can be easily solved by creating a new linked list and adding nodes to the new linked list with the final result. However, this takes up extra space and makes the question much less challenging. The interviewer will usually request that you modify the linked list in-place and the solve the problem without additional storage. You can borrow ideas from the [**_Reverse a Linked List_**](https://leetcode.com/problems/reverse-linked-list/) problem.

**_Elegant modification operations_**

As mentioned earlier, a linked list's non-sequential nature of memory allows for efficient modification of its contents. Unlike arrays where you can only modify the value at a position, for linked lists you can also modify the next pointer in addition to the value.

Here are some common operations and how they can be achieved easily:

- Truncate a list - Set the next pointer to null at the last element
- Swapping values of nodes - Just like arrays, just swap the value of the two nodes, there's no need to swap the next pointer
- Combining two lists - attach the head of the second list to the tail of the first list

## Implementing a List Node in JavaScript

As stated earlier, a list node contains two items: the data and the pointer to the next node. We can implement a list node in JavaScript as follows:

```js
class ListNode {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
```

## Implementing a Linked List in JavaScript

The code below shows the implementation of a linked list class with a constructor. Notice that if the head node is not passed, the head is initialised to null.

```js
class LinkedList {
  constructor(head = null) {
    this.head = head;
  }
}
```

## Putting it all together

Let's create a linked list with the class we just created. First, we create two list nodes, node1 and node2 and a pointer from node 1 to node 2.

```
let node1 = new ListNode(2)
let node2 = new ListNode(5)
node1.next = node2
```

Next, we'll create a Linked list with the node1.

```
let list = new LinkedList(node1)
```

Let's try to access the nodes in the list we just created.

```
console.log(list.head.next.data) //returns 5
```

## Some LinkedList methods

Next up, we will implement four helper methods for the linked list. They are:

1. size()
2. clear()
3. getLast()
4. getFirst()

## 1. size()

This method returns the number of nodes present in the linked list.

```js
size() {
    let count = 0;
    let node = this.head;
    while (node) {
        count++;
        node = node.next
    }
    return count;
}
```

## 2. clear()

This method empties out the list.

```js
clear() {
    this.head = null;
}
```

## 3. getLast()

This method returns the last node of the linked list.

```js
getLast() {
    let lastNode = this.head;
    if (lastNode) {
        while (lastNode.next) {
            lastNode = lastNode.next
        }
    }
    return lastNode
}
```

## 4. getFirst()

This method returns the first node of the linked list.

```js
getFirst() {
    return this.head;
}
```

**_Essential questions_**

These are essential questions to practice if you're studying for this topic.

[Reverse a Linked List](https://leetcode.com/problems/reverse-linked-list/)
[Detect Cycle in a Linked List](https://leetcode.com/problems/linked-list-cycle/)

**_Recommended practice questions_**

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
- [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [Remove Nth Node From End Of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- [Reorder List](https://leetcode.com/problems/reorder-list/)

# Queue cheatsheet

## Introduction

A queue is a linear collection of elements that are maintained in a sequence and can be modified by the addition of elements at one end of the sequence (enqueue operation) and the removal of elements from the other end (dequeue operation). Usually, the end of the sequence at which elements are added is called the back, tail, or rear of the queue, and the end at which elements are removed is called the head or front of the queue. As an abstract data type, queues can be implemented using arrays or singly linked lists.

This behavior is commonly called FIFO (first in, first out). The name "queue" for this type of structure comes from the analogy to people lining up in real life to wait for goods or services.

Breadth-first search is commonly implemented using queues.

## Time Complexity

| Operation     | Big-O |
| :------------ | :---: |
| Enqueue/Offer | O(1)  |
| Dequeue/Poll  | O(1)  |
| Front         | O(1)  |
| Back          | O(1)  |

## Things to look out for during interviews

Most languages don't have a built in Queue class which to be used, and candidates often use arrays (JavaScript) or lists (Python) as a queue. However, note that the enqueue operation in such a scenario will be O(n) because it requires shifting of all other elements by one. In such cases, you can flag this to the interviewer and say that you assume that there's a queue data structure to use which has an efficient enqueue operation.

Most languages don't have a built in Queue class which to be used, and candidates often use arrays (JavaScript) or lists (Python) as a queue. However, note that the enqueue operation in such a scenario will be O(n) because it requires shifting of all other elements by one. In such cases, you can flag this to the interviewer and say that you assume that there's a queue data structure to use which has an efficient enqueue operation.

## Queue Implementation

```js
class Queue {
  constructor() {
    this.elements = {};
    this.head = 0;
    this.tail = 0;
  }
  enqueue(element) {
    this.elements[this.tail] = element;
    this.tail++;
  }
  dequeue() {
    const item = this.elements[this.head];
    delete this.elements[this.head];
    this.head++;
    return item;
  }
  peek() {
    return this.elements[this.head];
  }
  get length() {
    return this.tail - this.head;
  }
  get isEmpty() {
    return this.length === 0;
  }
}
```

## How it works

First, initialize the object that stores the elements of the queue (elements) and two variables for tracking the head and tail in the constructor:

```js
class Queue {
  constructor() {
    this.elements = {};
    this.head = 0;
    this.tail = 0;
  }
  //...
}
```

Second, enqueue an element by adding it to the elements object to the end of the queue

```js
class Queue {
  //...
  enqueue(element) {
    this.elements[this.tail] = element;
    this.tail++;
  }

  //...
}
```

Third, remove an element from the front of the queue

```js
class Queue {
  // ...
  dequeue() {
    const item = this.elements[this.head];
    delete this.elements[this.head];
    this.head++;
    return item;
  }

  //...
}
```

Fourth, define the peek() method that accesses the element at the front of the queue

```js
class Queue {
  //...
  peek() {
    return this.elements[this.head];
  }
  //...
}
```

Fifth, get the length of the queue

```js
class Queue {
  //...
  get length() {
    return this.tail - this.head;
  }
  //...
}
```

The queue is empty when the length is zero.

Finally, define the isEmpty() method that returns true if the queue is empty:

```js
class Queue {
  // ...
  get isEmpty() {
    return this.tail - this.head;
  }
  // ...
}
```

## Create a new queue

To create a new queue from the Queue() constructor function, you use the new keyword as follows

```
let q = new Queue();
```

To enqueue numbers from 1 to 7, you use the following code.

```js
for (let i = 1; i <= 7; i++) {
  q.enqueue(i);
}
```

To get the number at the front of the queue, you use the peek() method.

```
console.log(q.peek()); // 1
```

To remove the element at the front of the queue, you use the dequeue() method as follows:

```js
// dequeue all elements
while (!q.isEmpty()) {
  console.log(q.dequeue());
}
```

put it all together

```js
class Queue {
  constructor() {
    this.elements = {};
    this.head = 0;
    this.tail = 0;
  }
  enqueue(element) {
    this.elements[this.tail] = element;
    this.tail++;
  }
  dequeue() {
    const item = this.elements[this.head];
    delete this.elements[this.head];
    this.head++;
    return item;
  }
  peek() {
    return this.elements[this.head];
  }
  get length() {
    return this.tail - this.head;
  }
  get isEmpty() {
    return this.length === 0;
  }
}

let q = new Queue();
for (let i = 1; i <= 7; i++) {
  q.enqueue(i);
}
// get the current item at the front of the queue
console.log(q.peek()); // 1

// get the current length of queue
console.log(q.length); // 7

// dequeue all elements
while (!q.isEmpty) {
  console.log(q.dequeue());
}
```

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues)

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks)
- [Design Circular Queue](https://leetcode.com/problems/design-circular-queue)

# Stack cheatsheet

## Introduction

A stack is an abstract data type that supports the operations push (insert a new element on the top of the stack) and pop (remove and return the most recently added element, the element at the top of the stack). As an abstract data type, stacks can be implemented using arrays or singly linked lists.

This behavior is commonly called LIFO (last in, first out). The name "stack" for this type of structure comes from the analogy to a set of physical items stacked on top of each other.

Stacks are an important way of supporting nested or recursive function calls and is used to implement depth-first search. Depth-first search can be implemented using recursion or a manual stack.

## Stack Implementation

First, how do we store the data? What can we use in JavaScript to hold data? We can use native objects like arrays, which we are familiar with and use built-in methods, push and pop. Ok, I guess we‚Äôre done, see you later‚Ä¶

Nah, to understand how a stack works under the hood, we use the base Object form.

We need a constructor to establish the storage mechanism and properties upon its invocation.

```js
// Stack class
class Stack {
  // Array is used to implement stack
  constructor() {
    this.items = [];
  }

  // Functions to be implemented
  // push(item)
  // pop()
  // peek()
  // isEmpty()
  // printStack()
}
```

As you can see the above definition we have created a skeleton of a stack class which contains a constructor in which we declare an array to implement stack. Hence, with the creation of an object of a stack class this constructor would be called automatically.

- PUSH: Adds an element to the stack and

```js
// push function
push(element);
{
  // push element into the items
  this.items.push(element);
}
```

This method adds an element at the top of the stack.

- POP: Removes an element from the stack

```js
// pop function
pop();
{
  // return top most element in the stack
  // and removes it from the stack
  // Underflow if stack is empty
  if (this.items.length == 0) return "Underflow";
  return this.items.pop();
}
```

This method returns the topmost element of stack and removes it.

- PEEK: returns the top most elements in the stack, but doesn‚Äôt delete it.

```js
// peek function
peek();
{
  // return the top most element from the stack
  // but does'nt delete it.
  return this.items[this.items.length - 1];
}
```

## Essential questions

These are essential questions to practice if you're studying for this topic.

- Valid Parentheses
- Implement Queue using Stacks

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)
- [Min Stack](https://leetcode.com/problems/min-stack)
- [Asteroid Collision](https://leetcode.com/problems/asteroid-collision)
- [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation)
- [Basic Calculator](https://leetcode.com/problems/basic-calculator)
- [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii)
- [Daily Temperatures](https://leetcode.com/problems/daily-temperatures)
- [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water)
- [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram)

# Tree cheatsheet

## Introduction

A tree is a widely used abstract data type that represents a hierarchical structure with a set of connected nodes. Each node in the tree can be connected to many children, but must be connected to exactly one parent, except for the root node, which has no parent.

A tree is an undirected and connected acyclic graph. There are no cycles or loops. Each node can be like the root node of its own subtree, making recursion a useful technique for tree traversal.

For the purpose of interviews, you will usually be asked on binary trees as opposed to ternary (3 children) or N-ary (N children) trees. In this page,we will cover binary trees and binary search trees, which is a special case of binary trees.

Trees are commonly used to represent hierarchical data, e.g. file systems, JSON, and HTML documents. Do check out the section on Trie, which is an advanced tree used for efficiently storing and searching strings.

## Common terms you need to know

- **_Neighbor_** - Parent or child of a node
- **_Ancestor_** - A node reachable by traversing its parent chain
  **_Descendant_** - A node in the node's subtree
- **_Degree_** - Number of children of a node
- **_Degree_** of a tree - Maximum degree of nodes in the tree
- **_Distance_** - Number of edges along the shortest path between two nodes
- **_Level/Depth_** - Number of edges along the unique path between a node and the root node
- **_Width_** - Number of nodes in a level

## Binary tree

Binary means two, so nodes in a binary trees have a maximum of two children.

## Binary tree terms

- Complete binary tree - A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.
- Balanced binary tree - A binary tree structure in which the left and right subtrees of every node differ in height by no more than 1.

## Traversals

![tree image](https://upload.wikimedia.org/wikipedia/commons/5/5e/Binary_tree_v2.svg)

Given such a tree, these are the results for the various traversals.

- **_In-order traversal_** - Left -> Root -> Right
  - Result: 2, 7, 5, 6, 11, 1, 9, 5, 9
- **_Pre-order traversal_** - Root -> Left -> Right
  - Result: 1, 7, 2, 6, 5, 11, 9, 9, 5
- **_Post-order traversal_** - Left -> Right -> Root
  - Result: 2, 5, 11, 6, 7, 5, 9, 9, 1

Note that in-order traversal of a binary tree is insufficient to uniquely serialize a tree. Pre-order or post-order traversal is also required.

## Binary search tree (BST)

In-order traversal of a BST will give you all elements in order.

Be very familiar with the properties of a BST and validating that a binary tree is a BST. This comes up more often than expected.

When a question involves a BST, the interviewer is usually looking for a solution which runs faster than O(n)

## Things to look out for during interviews

You should be very familiar with writing pre-order, in-order, and post-order traversal recursively. As an extension, challenge yourself by writing them iteratively. Sometimes interviewers ask candidates for the iterative approach, especially if the candidate finishes writing the recursive approach too quickly.

## Common routines

Be familiar with the following routines because many tree questions make use of one or more of these routines in the solution:

- Insert value
- Delete value
- Count number of nodes in tree
- Whether a value is in the tree
- Calculate height of the tree
- Binary search tree
  - Determine if is binary search tree
  - Get maximum value
  - Get minimum value

## Techniques

**_Use recursion_**

Recursion is the most common approach for traversing trees. When you notice that the subtree problem can be used to solve the entire problem, try using recursion.

When using recursion, always remember to check for the base case, usually where the node is null.

Sometimes it is possible that your recursive function needs to return two values.

**_Traversing by level_**

When you are asked to traverse a tree by level, use breadth-first search.

**_Summation of nodes_**

If the question involves summation of nodes along the way, be sure to check whether nodes can be negative.

## Essential questions

These are essential questions to practice if you're studying for this topic.

- Binary Tree
  - [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
  - [Invert/Flip Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
- Binary Search Tree
  - [Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- Binary tree
  - [Same Tree](https://leetcode.com/problems/same-tree/)
  - [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
  - [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
  - [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)
  - [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)
  - [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)
  - [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
  - [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)
- Binary search tree
  - [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)
  - [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

# Graph cheatsheet

## Introduction

A graph is a structure containing a set of objects (nodes or vertices) where there can be edges between these nodes/vertices. Edges can be directed or undirected and can optionally have values (a weighted graph). Trees are undirected graphs in which any two vertices are connected by exactly one edge and there can be no cycles in the graph.

Graphs are commonly used to model relationship between unordered entities, such as

Friendship between people - Each node is a person and edges between nodes represent that these two people are friends.
Distances between locations - Each node is a location and the edge between nodes represent that these locations are connected. The value of the edge represent the distance.

Be familiar with the various graph representations, graph search algorithms and their time and space complexities.

## Graph representations

You can be given a list of edges and you have to build your own graph from the edges so that you can perform a traversal on them. The common graph representations are:

- Adjacency matrix
- Adjacency list
- Hash table of hash tables

Using a hash table of hash table would be the simplest approach during algorithm interviews. It will be rare that you have to use adjacency matrix or list for graph questions during interviews.

In algorithm interviews, graphs are commonly given in the input as 2D matrices where cells are the nodes and each cell can traverse to its adjacent cells (up/down/left/right). Hence it is important that you be familiar with traversing a 2D matrix. When traversing the matrix, always ensure that your current position is within the boundary of the matrix and has not been visited before.

Things to look out for during interviews

- A tree-like diagram could very well be a graph that allows for cycles and a naive recursive solution would not work. In that case you will have to handle cycles and keep a set of visited nodes when traversing.

- Ensure you are correctly keeping track of visited nodes and not visiting each node more than once. Otherwise your code could end up in an infinite loop.

## Graph search algorithms

- **_Common_** - Breadth-first Search, Depth-first Search
- **_Uncommon_** - Topological Sort, Dijkstra's algorithm
- **_Almost never_** - Bellman-Ford algorithm, Floyd-Warshall algorithm, Prim's algorithm, Kruskal's algorithm. Your interviewer likely don't know them either.

## Depth-first search

Depth-first search is a graph traversal algorithm which explores as far as possible along each branch before backtracking. A stack is usually used to keep track of the nodes that are on the current search path. This can be done either by an implicit recursion stack, or an actual stack data structure.

## Depth First Search Implementation

DFS visits the nodes depth wise. Since we need to process the nodes in a Last In First Out manner, we‚Äôll use a stack.

Starting from a vertex, we‚Äôll push the neighboring vertices to our stack. Whenever a vertex is popped, it is marked visited in our visited object. Its neighboring vertices are pushed to the stack. Since we are always popping a new adjacent vertex, our algorithm will always explore a new level.

We can also use the intrinsic stack calls to implement DFS recursively. The logic is the same.

The time complexity is the same as BFS, O(V+E).

lets pseudocode it first

```
function DFS
   Initialize an empty stack, empty 'result' array & a 'visited' map
   Add the starting vertex to the stack & visited map
   While Stack is not empty:
     - Pop and store current vertex
     - Push current vertex to result array
     - Iterate through current vertex's adjacency list:
       - For each adjacent vertex, if vertex is unvisited:
         - Add vertex to visited map
         - Push vertex to stack
   Return result array
```

```js
Graph.prototype.bfs = function (start) {
  const queue = [start];
  const result = [];
  const visited = {};
  visited[start] = true;
  let currentVertex;
  while (queue.length) {
    currentVertex = queue.shift();
    result.push(currentVertex);
    this.adjacencyList[currentVertex].forEach((neighbor) => {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        queue.push(neighbor);
      }
    });
  }
  return result;
};
```

## Breadth-first search

Breadth-first search is a graph traversal algorithm which starts at a node and explores all nodes at the present depth, before moving on to the nodes at the next depth level. A queue is usually used to keep track of the nodes that were encountered but not yet explored.

A similar template for doing breadth-first searches on the matrix goes like this. It is important to use double-ended queues and not arrays/Python lists as enqueuing for double-ended queues is O(1) but it's O(n) for arrays.

## Breadth First Search Implementation

BFS visits the nodes one level at a time. To prevent visiting the same node more than once, we‚Äôll maintain a visited object.

Since we need to process the nodes in a First In First Out fashion, a queue is a good contender for the data structure to use. The time complexity is O(V+E).

lets pseudocode it first

```
function BFS
   Initialize an empty queue, empty 'result' array & a 'visited' map
   Add the starting vertex to the queue & visited map
   While Queue is not empty:
     - Dequeue and store current vertex
     - Push current vertex to result array
     - Iterate through current vertex's adjacency list:
       - For each adjacent vertex, if vertex is unvisited:
         - Add vertex to visited map
         - Enqueue vertex
   Return result array
```

```js
Graph.prototype.bfs = function (start) {
  const queue = [start];
  const result = [];
  const visited = {};
  visited[start] = true;
  let currentVertex;
  while (queue.length) {
    currentVertex = queue.shift();
    result.push(currentVertex);
    this.adjacencyList[currentVertex].forEach((neighbor) => {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        queue.push(neighbor);
      }
    });
  }
  return result;
};
```

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [Flood Fill](https://leetcode.com/problems/flood-fill)
- [01 Matrix](https://leetcode.com/problems/01-matrix/)

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- Breadth-first search
  - [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)
- Either search
  - [Clone Graph](https://leetcode.com/problems/clone-graph/)
  - [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)
- Topological sorting
  - [Course Schedule](https://leetcode.com/problems/course-schedule/)

# Heap cheatsheet

## Introductions

A heap is a specialized tree-based data structure which is a complete tree that satisfies the heap property.

- Max heap - In a max heap the value of a node must be greatest among the node values in its entire subtree. The same property must be recursively true for all nodes in the tree.
- Min heap - In a min heap the value of a node must be smallest among the node values in its entire subtree. The same property must be recursively true for all nodes in the tree.

In the context of algorithm interviews, heaps and priority queues can be treated as the same data structure. A heap is a useful data structure when it is necessary to repeatedly remove the object with the highest (or lowest) priority, or when insertions need to be interspersed with removals of the root node.

## Techniques

**_Mention of k_**

If you see a top or lowest k being mentioned in the question, it is usually a signal that a heap can be used to solve the problem, such as in Top K Frequent Elements.

If you require the top k elements use a Min Heap of size k. Iterate through each element, pushing it into the heap (for python heapq, invert the value before pushing to find the max). Whenever the heap size exceeds k, remove the minimum element, that will guarantee that you have the k largest elements.

## Essential questions

These are essential questions to practice if you're studying for this topic.

- [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)

## Recommended practice questions

These are recommended questions to practice after you have studied for the topic and have practiced the essential questions.

- [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)
- [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

# Learning Resources

- Arrays

  - Readings

    - [Array in Data Structure: What is, Arrays Operations](https://www.guru99.com/array-data-structure.html)

  - Videos
    - [Arrays](https://www.coursera.org/lecture/data-structures/arrays-OsBSF), University of California San Diego

- Hash Tables

  - Readings

    - [Taking Hash Tables Off The Shelf](https://medium.com/basecs/taking-hash-tables-off-the-shelf-139cbf4752f0)
    - [Hashing Out Hah Functions](https://medium.com/basecs/hashing-out-hash-functions-ea5dd8beb4dd)

  - Videos
    - [Core: Hash Tables](https://www.coursera.org/lecture/data-structures-optimizing-performance/core-hash-tables-m7UuP) University of California San Diego
    - [A Brief Guide to Hash Tables ](https://www.youtube.com/watch?v=r1XZGP5ppqQ) [slides](https://samuelalbanie.com/files/digest-slides/2022-09-brief-guide-to-hash-tables.pdf) Samuel Albanie, University of Cambridge

- Linked List

  - Readings

    - [What's a Linked List, Anyway? [Part 1]](https://medium.com/basecs/whats-a-linked-list-anyway-part-1-d8b7e6508b9d)
    - [What's a Linked List, Anyway? [Part 2]](https://medium.com/basecs/whats-a-linked-list-anyway-part-2-131d96f71996)
    - [The top 20 linked list interview questions](https://www.geeksforgeeks.org/top-20-linked-list-interview-question/).

  - Videos
    - [Singly-linked lists](https://www.coursera.org/lecture/data-structures/singly-linked-lists-kHhgK) University of California San Diego
    - [Doubly linked lists](https://www.coursera.org/lecture/data-structures/doubly-linked-lists-jpGKD)

- Queue

  - Readings

    - [To Queue Or Not To Queue](https://medium.com/basecs/to-queue-or-not-to-queue-2653bcde5b04)

  - Videos
    - [Queues](https://www.coursera.org/lecture/data-structures/queues-EShpq), University of California San Diego

- Stack

  - Readings

    - [Stacks and Overflows](https://medium.com/basecs/stacks-and-overflows-dbcf7854dc67)

  - Videos
    - [Stacks](https://www.coursera.org/lecture/data-structures/stacks-UdKzQ), University of California San Diego

- Tree

  - Videos

    - [Trees](https://www.coursera.org/lecture/data-structures/trees-95qda), University of California San Diego
    - [A Brief Guide to Binary Search Trees](https://www.youtube.com/watch?v=0woI8l0ZWmA) [slides](https://samuelalbanie.com/files/digest-slides/2022-10-brief-guide-to-binary-search-trees.pdf), Samuel Albanie, University of Cambridge
    - [A Brief Guide to Red-Black Trees]() [slides](https://samuelalbanie.com/files/digest-slides/2022-12-brief-guide-to-red-black-trees.pdf), Samuel Albanie, University of Cambridge
    - [A Brief Guide to B-trees](https://www.youtube.com/watch?app=desktop&v=7MqaHGWRS3E) [slides](https://samuelalbanie.com/files/digest-slides/2022-12-brief-guide-to-b-trees.pdf), Samuel Albanie, University of Cambridge

  - Readings

    - [How To Not Be Stumped By Trees](https://medium.com/basecs/how-to-not-be-stumped-by-trees-5f36208f68a7)
    - [Leaf It Up To Binary Trees](https://medium.com/basecs/leaf-it-up-to-binary-trees-11001aaf746d)

  - Additional (only if you have time)

    - [The Little AVL Tree That Could](https://medium.com/basecs/the-little-avl-tree-that-could-86a3cae410c7)
    - [Busying Oneself With B-Tree](https://medium.com/basecs/busying-oneself-with-b-trees-78bbf10522e7)
    - [Painting Nodes Black With Red-Black Trees](https://medium.com/basecs/painting-nodes-black-with-red-black-trees-60eacb2be9a5)

- Graph

  - Readings

    - [From Theory To Practice: Representing Graphs](https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38)
    - [Deep Dive Through A Graph: DFS Traversal](https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13)
    - [Going Broad In A Graph: BFS Traversal](https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255)

  - Additional (only if you have time)
    - [Finding The Shortest Path, With A Little Help From Dijkstra](https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e)
    - [Spinning Around In Cycles With Directed Acyclic Graphs](https://medium.com/basecs/spinning-around-in-cycles-with-directed-acyclic-graphs-a233496d4688)

- Heaps

  - Readings

    - [Learning to Love Heaps](https://medium.com/basecs/learning-to-love-heaps-cef2b273a238)
    - [Heapify All The Things With Heap Sort](https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82)
    - [Heaps](http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#heaps), James Aspnes, Yale University
